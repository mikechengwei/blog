# C的指针 分析

##示例说明不同指针表达式的左右值语义
示例:

    char ch='a';
    char *cp=&ch;

cp:一个保存ch地址的值.<br>
*cp:指的是cp指向的地址的值。

参照上面的示例,描述一下不同表达式，左值和右值得意义:

| 表达式  | 右值  | 左值 |
|:------------- |:---------------:| -------------:|
| &ch     | ch的地址 |         非法    |
| cp      | cp的值       |     cp所处的内存位置      |
| &cp | 指针变量cp的地址        |            非法      |
| *cp | cp所指向的地址的值        |           cp所指向的内存位置      |
| *cp +1   | cp所指向的地址的值 +1       |    非法     |
| *(cp +1)| cp所指向的位置前进一个      |    非法     |
| cp++ | 先返回cp的一份拷贝，cp的值再加1      |    非法    |
| ++cp | cp的值加1后返回cp的拷贝     |    非法     |
| *++cp | cp所指向位置的后面一个值     |    cp所指向位置的后面一个位置     |
| *cp++ | cp所指向位置的值     |    cp所指向的位置|
| ++*cp | 对cp所指向位置的值加1     |    非法 |
| (*cp)++ | 拷贝cp所指向位置的值,并加1     |    非法 |
| ++*++cp | 拷贝cp所指向位置后面一个位置的值加1     |    非法 |
| ++*cp++ | 指向cp所指向的位置然后加1，产生一份拷贝     |    非法 |

注意: 书上说是++比*的优先级要高.但是不要用这个规则来分析上述表达式的语义。

我简单总结:
 
 * 当*和++都在左边的时候,按照从右向左分析语义
 * 如果* ++分布在变量的两边的时候，先后缀++,然后*.  
 * +操作符比*优先级低
 * *cp++ 解释下过程:
  1. ++操作符产生一份cp的拷贝
  2. 然后++操作符增加cp的值
  3. 最后在cp的拷贝上进行上执行间接访问操作。<br>
 * 同理*++cp 解释过程
  1. ++操作符增加cp的值
  2. 然后产生一份拷贝
  3. 最后在这份拷贝上执行间接访问操作
  
##学习程序
用指针代替数组存字符串的小demo.<br>
因为C中空间都要事先分配,我表示我也很尴尬.

    char *str=(char *)malloc(10);
    printf("%d\n",str);
    *str='a';
    printf("%d———%c\n",str,*str);
    *++str='b';
    printf("%d———%c\n\n",str,*str);
    
* *str默认指向的是所分配内存的第一个位置

##总结
 
 * C指针和数组两者是可以替换的,用数组的地方可以换成指针。


